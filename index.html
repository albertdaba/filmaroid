<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Camera PWA ‚Äì Film App (Mobile Optimized)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000000">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Mrs+Saint+Delafield&display=swap">
  <style>
:root {
  --ui-scale: 1;
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top: env(safe-area-inset-top, 0px);
}

* { 
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  background: #000;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size: 14px;
  height: 100vh;
  overflow: hidden;
  position: fixed;
  width: 100%;
}

/* ========== VIEWFINDER ========== */
#viewfinder-container {
  position: fixed;
  top: var(--safe-top);
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
}

video, canvas, #photo {
  width: 100%;
  max-width: 480px;
  aspect-ratio: 3/4;
  object-fit: contain;
  background: #000;
}

#video {
  display: block;
}

canvas, #photo {
  display: none;
}

/* ========== TOP BAR ========== */
#top-bar {
  position: fixed;
  top: var(--safe-top);
  left: 0;
  right: 0;
  height: 60px;
  background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 20px;
  z-index: 10;
  pointer-events: none;
}

#top-bar button {
  pointer-events: auto;
  background: rgba(0,0,0,0.5);
  border: 1px solid rgba(255,255,255,0.3);
  color: #fff;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 13px;
  backdrop-filter: blur(10px);
  cursor: pointer;
}

/* ========== SHUTTER & CONTROLS BAR ========== */
#bottom-controls {
  position: fixed;
  bottom: calc(var(--safe-bottom) + 20px);
  left: 0;
  right: 0;
  height: 90px;
  display: flex;
  align-items: center;
  justify-content: space-around;
  padding: 0 20px;
  z-index: 10;
  background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
}

#shutter {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  border: 4px solid #fff;
  background: rgba(255,255,255,0.1);
  cursor: pointer;
  transition: transform 0.1s;
}

#shutter:active {
  transform: scale(0.95);
}

#menu-trigger, #next-btn, #save-btn, #text-btn {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: #fff;
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(10px);
}

#next-btn, #save-btn, #text-btn {
  display: none;
}

/* ========== BOTTOM SHEET ========== */
#bottom-sheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: #1c1c1e;
  border-radius: 20px 20px 0 0;
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 50;
  max-height: 70vh;
  display: flex;
  flex-direction: column;
  padding-bottom: var(--safe-bottom);
}

#bottom-sheet.expanded {
  transform: translateY(0);
}

#sheet-handle {
  width: 40px;
  height: 5px;
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
  margin: 12px auto 8px;
  cursor: grab;
}

#sheet-title {
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  padding: 0 20px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

/* ========== TABS ========== */
#tabs {
  display: flex;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  background: #1c1c1e;
  position: sticky;
  top: 0;
  z-index: 1;
}

.tab {
  flex: 1;
  padding: 12px 8px;
  text-align: center;
  font-size: 13px;
  color: rgba(255,255,255,0.6);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
}

.tab.active {
  color: #fff;
  border-bottom-color: #007aff;
}

/* ========== TAB CONTENT ========== */
#tab-content {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tab-panel {
  display: none;
  padding: 16px;
}

.tab-panel.active {
  display: block;
}

/* ========== FORM CONTROLS ========== */
.control-group {
  margin-bottom: 20px;
}

.control-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
  color: rgba(255,255,255,0.8);
}

.control-value {
  color: #007aff;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 36px;
  -webkit-appearance: none;
  background: transparent;
  margin: 0;
}

input[type="range"]::-webkit-slider-track {
  width: 100%;
  height: 4px;
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 24px;
  width: 24px;
  border-radius: 50%;
  background: #fff;
  cursor: pointer;
  margin-top: -10px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

input[type="range"]::-moz-range-track {
  width: 100%;
  height: 4px;
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
}

input[type="range"]::-moz-range-thumb {
  height: 24px;
  width: 24px;
  border-radius: 50%;
  background: #fff;
  cursor: pointer;
  border: none;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

select {
  width: 100%;
  padding: 10px 14px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 10px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
}

/* ========== PRESET GRID ========== */
#preset-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
}

.preset-card {
  padding: 16px 12px;
  background: rgba(255,255,255,0.08);
  border: 2px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  cursor: pointer;
  text-align: center;
  transition: all 0.2s;
  position: relative;
}

.preset-card:active {
  transform: scale(0.98);
}

.preset-card.active {
  background: rgba(0,122,255,0.2);
  border-color: #007aff;
}

.preset-share-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(0,122,255,0.8);
  border: none;
  color: #fff;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 2;
}

.preset-share-btn:active {
  transform: scale(0.9);
}

.preset-delete-btn {
  position: absolute;
  top: 8px;
  left: 8px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(255,59,48,0.8);
  border: none;
  color: #fff;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 2;
}

.preset-delete-btn:active {
  transform: scale(0.9);
}

.preset-name {
  font-weight: 600;
  font-size: 14px;
  margin-bottom: 4px;
}

.preset-desc {
  font-size: 11px;
  color: rgba(255,255,255,0.6);
}

/* ========== COLOR MIX ========== */
.color-palette {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  overflow-x: auto;
  padding-bottom: 8px;
  -webkit-overflow-scrolling: touch;
}

.color-chip {
  min-width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 3px solid transparent;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.color-chip.selected {
  border-color: #fff;
  box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
}

.color-info {
  font-size: 12px;
  color: rgba(255,255,255,0.7);
  margin-bottom: 12px;
  padding: 8px 12px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
}

.toggle-section {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  margin-bottom: 16px;
}

.toggle-section input[type="checkbox"] {
  width: 50px;
  height: 28px;
  -webkit-appearance: none;
  background: rgba(255,255,255,0.2);
  border-radius: 14px;
  position: relative;
  cursor: pointer;
  transition: background 0.2s;
}

.toggle-section input[type="checkbox"]:checked {
  background: #007aff;
}

.toggle-section input[type="checkbox"]::before {
  content: '';
  position: absolute;
  width: 24px;
  height: 24px;
  background: #fff;
  border-radius: 50%;
  top: 2px;
  left: 2px;
  transition: transform 0.2s;
}

.toggle-section input[type="checkbox"]:checked::before {
  transform: translateX(22px);
}

/* ========== TRICOLOR WHEEL ========== */
.tricolor-section {
  margin-bottom: 16px;
}

.tricolor-label {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #fff;
}

.hue-wheel {
  width: 100%;
  height: 50px;
  border-radius: 25px;
  margin-bottom: 12px;
  background: linear-gradient(to right, 
    hsl(0, 100%, 50%),
    hsl(30, 100%, 50%),
    hsl(60, 100%, 50%),
    hsl(90, 100%, 50%),
    hsl(120, 100%, 50%),
    hsl(150, 100%, 50%),
    hsl(180, 100%, 50%),
    hsl(210, 100%, 50%),
    hsl(240, 100%, 50%),
    hsl(270, 100%, 50%),
    hsl(300, 100%, 50%),
    hsl(330, 100%, 50%),
    hsl(360, 100%, 50%)
  );
  position: relative;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  --indicator-left: 50%;
}

.hue-wheel::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 3px solid #fff;
  top: 50%;
  left: var(--indicator-left);
  transform: translate(-50%, -50%);
  pointer-events: none;
  box-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

/* ========== BUTTONS ========== */
.btn-primary {
  width: 100%;
  padding: 12px;
  background: #007aff;
  border: none;
  border-radius: 12px;
  color: #fff;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: opacity 0.2s;
}

.btn-primary:active {
  opacity: 0.8;
}

.btn-secondary {
  width: 100%;
  padding: 12px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 12px;
  color: #fff;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  margin-top: 12px;
}

/* ========== PROCESSING OVERLAY ========== */
#processing {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  font-size: 16px;
  backdrop-filter: blur(5px);
}

/* ========== TEXT MODAL ========== */
#text-modal {
  position: fixed;
  bottom: calc(var(--safe-bottom) + 20px);
  left: 20px;
  right: 20px;
  background: #1c1c1e;
  padding: 20px;
  border-radius: 16px;
  display: none;
  flex-direction: column;
  gap: 12px;
  z-index: 60;
}

#text-modal input {
  width: 100%;
  padding: 14px 16px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 10px;
  color: #fff;
  font-size: 16px;
  user-select: auto;
  -webkit-user-select: auto;
}

#text-modal .modal-buttons {
  display: flex;
  gap: 12px;
}

#text-modal .modal-buttons button {
  flex: 1;
  padding: 12px;
  border-radius: 10px;
  border: none;
  font-size: 16px;
  cursor: pointer;
}

/* ========== GALLERY ========== */
#gallery-overlay {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 100;
  display: none;
  flex-direction: column;
  padding: var(--safe-top) 0 var(--safe-bottom) 0;
}

#gallery-header {
  padding: 16px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

#gallery-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 12px;
}

#gallery-content img {
  width: 100%;
  border-radius: 8px;
  aspect-ratio: 3/4;
  object-fit: cover;
}

/* ========== CAMERA SELECTOR ========== */
#camera-selector {
  position: fixed;
  bottom: calc(var(--safe-bottom) + 120px);
  left: 20px;
  background: rgba(0,0,0,0.8);
  border-radius: 12px;
  padding: 12px;
  display: none;
  flex-direction: column;
  gap: 8px;
  backdrop-filter: blur(10px);
  z-index: 15;
}

.camera-option {
  padding: 10px 14px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  color: #fff;
  font-size: 13px;
  cursor: pointer;
  white-space: nowrap;
  min-width: 150px;
}

.camera-option:active {
  background: rgba(255,255,255,0.2);
}

.divider {
  height: 1px;
  background: rgba(255,255,255,0.1);
  margin: 16px 0;
}

#photo {
  user-select: auto;
  -webkit-user-select: auto;
}

  </style>
</head>
<body>

<!-- Viewfinder -->
<div id="viewfinder-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <img id="photo">
</div>

<!-- Top Bar -->
<div id="top-bar">
  <button id="camera-switch">üì∑</button>
  <button id="gallery-btn">Gallery</button>
</div>

<!-- Bottom Controls -->
<div id="bottom-controls">
  <button id="menu-trigger">‚ò∞</button>
  <button id="shutter"></button>
  <button id="save-btn">üíæ</button>
  <button id="next-btn">‚Ü©</button>
  <button id="text-btn">T</button>
</div>

<!-- Bottom Sheet -->
<div id="bottom-sheet">
  <div id="sheet-handle"></div>
  <div id="sheet-title">Film Controls</div>
  
  <div id="tabs">
    <button class="tab active" data-tab="presets">Presets</button>
    <button class="tab" data-tab="effects">Effects</button>
    <button class="tab" data-tab="colors">Colors</button>
  </div>
  
  <div id="tab-content">
    <!-- PRESETS TAB -->
    <div class="tab-panel active" id="presets-panel">
      <div id="preset-grid">
        <div class="preset-card active" data-preset="kodachrome">
          <div class="preset-name">Kodachrome</div>
          <div class="preset-desc">Classic warm</div>
        </div>
        <div class="preset-card" data-preset="acros">
          <div class="preset-name">Acros</div>
          <div class="preset-desc">B&W film</div>
        </div>
        <div class="preset-card" data-preset="velvia">
          <div class="preset-name">Velvia</div>
          <div class="preset-desc">Vibrant colors</div>
        </div>
        <div class="preset-card" data-preset="provia">
          <div class="preset-name">Provia</div>
          <div class="preset-desc">Natural tones</div>
        </div>
      </div>
      
      <div class="divider"></div>
      
      <div id="custom-profiles"></div>
      
      <button class="btn-secondary" id="save-profile-btn">Save Current as Profile</button>
      <button class="btn-secondary" id="import-preset-btn">Import Shared Preset</button>
    </div>
    
    <!-- EFFECTS TAB -->
    <div class="tab-panel" id="effects-panel">
      <div class="control-group">
        <div class="control-label">
          <span>Film Grain</span>
          <span class="control-value" id="grain-val">0</span>
        </div>
        <input type="range" id="grain" min="0" max="50" value="0">
      </div>
      
      <div class="control-group">
        <div class="control-label">
          <span>JPEG Quality</span>
          <span class="control-value" id="jpeg-quality-val">60%</span>
        </div>
        <input type="range" id="jpeg-quality" min="20" max="100" value="60">
      </div>
      
      <div class="divider"></div>
      
      <div class="toggle-section">
        <input type="checkbox" id="halation-enable">
        <label for="halation-enable">Halation Effect</label>
      </div>
      
      <div id="halation-wrapper" style="display:none">
        <div class="control-group">
          <div class="control-label">
            <span>Spread</span>
            <span class="control-value" id="halation-blur-val">10</span>
          </div>
          <input type="range" id="halation-blur" min="0" max="50" value="10">
        </div>
        
        <div class="control-group">
          <div class="control-label">
            <span>Strength</span>
            <span class="control-value" id="halation-strength-val">50</span>
          </div>
          <input type="range" id="halation-strength" min="0" max="100" value="50">
        </div>
        
        <div class="control-group">
          <div class="control-label">
            <span>Threshold</span>
            <span class="control-value" id="halation-threshold-val">200</span>
          </div>
          <input type="range" id="halation-threshold" min="0" max="255" value="200">
        </div>
      </div>
      
      <div class="divider"></div>
      
      <div class="control-group">
        <div class="control-label">
          <span>White Balance - Red</span>
          <span class="control-value" id="wb-r-val">0</span>
        </div>
        <input type="range" id="wb-r" min="-8" max="8" value="0">
      </div>
      
      <div class="control-group">
        <div class="control-label">
          <span>White Balance - Blue</span>
          <span class="control-value" id="wb-b-val">0</span>
        </div>
        <input type="range" id="wb-b" min="-8" max="8" value="0">
      </div>
      
      <div class="control-group">
        <div class="control-label">
          <span>Vignette</span>
          <span class="control-value" id="vig-val">0</span>
        </div>
        <input type="range" id="vignette" min="0" max="100" value="0">
      </div>
    </div>
    
    <!-- COLORS TAB -->
    <div class="tab-panel" id="colors-panel">
      <div class="toggle-section">
        <input type="checkbox" id="cm-enable">
        <label for="cm-enable">Per-Color Adjustments</label>
      </div>
      
      <div id="cm-wrapper" style="display:none">
        <div class="color-palette" id="color-palette"></div>
        
        <div class="color-info" id="color-info">Select a color to adjust</div>
        
        <div class="control-group">
          <div class="control-label">
            <span>Hue Shift</span>
            <span class="control-value" id="cm-h-val">0¬∞</span>
          </div>
          <input type="range" id="cm-h" min="-30" max="30" value="0">
        </div>
        
        <div class="control-group">
          <div class="control-label">
            <span>Saturation</span>
            <span class="control-value" id="cm-s-val">0</span>
          </div>
          <input type="range" id="cm-s" min="-100" max="100" value="0">
        </div>
        
        <div class="control-group">
          <div class="control-label">
            <span>Luminance</span>
            <span class="control-value" id="cm-l-val">0</span>
          </div>
          <input type="range" id="cm-l" min="-100" max="100" value="0">
        </div>
        
        <button class="btn-secondary" id="cm-reset">Reset All Colors</button>
      </div>
      
      <div class="divider"></div>
      
      <div class="toggle-section">
        <input type="checkbox" id="tricolor-enable">
        <label for="tricolor-enable">Tricolor Wheel</label>
      </div>
      
      <div id="tricolor-wrapper" style="display:none">
        <div class="tricolor-section">
          <div class="tricolor-label">Shadows</div>
          <div class="hue-wheel" id="shadow-wheel"></div>
          <div class="control-group">
            <div class="control-label">
              <span>Hue</span>
              <span class="control-value" id="shadow-hue-val">180¬∞</span>
            </div>
            <input type="range" id="shadow-hue" min="0" max="360" value="180">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Strength</span>
              <span class="control-value" id="shadow-str-val">0%</span>
            </div>
            <input type="range" id="shadow-strength" min="0" max="100" value="0">
          </div>
        </div>
        
        <div class="divider"></div>
        
        <div class="tricolor-section">
          <div class="tricolor-label">Midtones</div>
          <div class="hue-wheel" id="midtone-wheel"></div>
          <div class="control-group">
            <div class="control-label">
              <span>Hue</span>
              <span class="control-value" id="midtone-hue-val">180¬∞</span>
            </div>
            <input type="range" id="midtone-hue" min="0" max="360" value="180">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Strength</span>
              <span class="control-value" id="midtone-str-val">0%</span>
            </div>
            <input type="range" id="midtone-strength" min="0" max="100" value="0">
          </div>
        </div>
        
        <div class="divider"></div>
        
        <div class="tricolor-section">
          <div class="tricolor-label">Highlights</div>
          <div class="hue-wheel" id="highlight-wheel"></div>
          <div class="control-group">
            <div class="control-label">
              <span>Hue</span>
              <span class="control-value" id="highlight-hue-val">180¬∞</span>
            </div>
            <input type="range" id="highlight-hue" min="0" max="360" value="180">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Strength</span>
              <span class="control-value" id="highlight-str-val">0%</span>
            </div>
            <input type="range" id="highlight-strength" min="0" max="100" value="0">
          </div>
        </div>
        
        <button class="btn-secondary" id="tricolor-reset">Reset Tricolor</button>
      </div>
    </div>
  </div>
</div>

<!-- Camera Selector -->
<div id="camera-selector"></div>

<!-- Text Modal -->
<div id="text-modal">
  <input type="text" id="text-input" maxlength="50" placeholder="Enter text for photo" style="font-size: 14px;">
  <div class="modal-buttons">
    <button id="text-cancel" style="background: rgba(255,255,255,0.1); color: #fff; font-size: 14px; padding: 10px;">Cancel</button>
    <button id="text-submit" style="background: #007aff; color: #fff; font-size: 14px; padding: 10px;">Add Text</button>
  </div>
</div>

<!-- Gallery -->
<div id="gallery-overlay">
  <div id="gallery-header">
    <h2 style="font-size: 18px; font-weight: 600;">Gallery</h2>
    <button id="gallery-close" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; padding: 6px 14px; border-radius: 20px; font-size: 13px;">Close</button>
  </div>
  <div id="gallery-content"></div>
</div>

<!-- Processing -->
<div id="processing">
  <div style="text-align: center;">
    <div style="font-size: 16px; margin-bottom: 8px;">Processing...</div>
    <div style="font-size: 13px; opacity: 0.7;">Applying film simulation</div>
  </div>
</div>

<select id="cameraSelect" style="display:none"></select>

<script>
/* ========== DOM REFS ========== */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const photo = document.getElementById('photo');
const shutter = document.getElementById('shutter');
const saveBtn = document.getElementById('save-btn');
const nextBtn = document.getElementById('next-btn');
const textBtn = document.getElementById('text-btn');
const processingEl = document.getElementById('processing');
const cameraSelect = document.getElementById('cameraSelect');
const bottomSheet = document.getElementById('bottom-sheet');
const menuTrigger = document.getElementById('menu-trigger');
const sheetHandle = document.getElementById('sheet-handle');

/* ========== STATE ========== */
let stream = null;
let grainAmt = 0;
let film = 'kodachrome';
let jpegQ = 60;
let userText = '';
let dim = null;
let lastFrameImageData = null;
let activeProfileName = null;

const PROFILE_KEY = 'filmProfilesV1';
let profiles = {};

const colors = [
  {name:'Red', css:'#ff3b30', center:0.00},
  {name:'Orange', css:'#ff9500', center:0.06},
  {name:'Yellow', css:'#ffcc00', center:0.12},
  {name:'Green', css:'#34c759', center:0.33},
  {name:'Aqua', css:'#32d7d7', center:0.50},
  {name:'Blue', css:'#007aff', center:0.62},
  {name:'Purple', css:'#9b59ff', center:0.75},
  {name:'Magenta', css:'#ff2d7a', center:0.88},
];
const hueWidth = [0.09,0.10,0.08,0.07,0.06,0.07,0.07,0.08];
let cmIdx = 0;

const CM_KEY = 'colorMixSettingsV1';
let cmState = { enable:false, dH:new Array(8).fill(0), dS:new Array(8).fill(0), dL:new Array(8).fill(0) };

const WB_KEY = 'wbSettingsV1';
let wb = { r:0, b:0 };
let vignetteAmt = 0;

/* ========== TRICOLOR WHEEL STATE ========== */
const TRICOLOR_KEY = 'tricolorSettingsV1';
let tricolorState = {
  enable: false,
  shadow: { hue: 180, strength: 0 },
  midtone: { hue: 180, strength: 0 },
  highlight: { hue: 180, strength: 0 }
};

/* ========== HALATION STATE ========== */
const HALATION_KEY = 'halationSettingsV1';
let halationState = {
  enable: false,
  blur: 10,
  strength: 50,
  threshold: 200
};

/* ========== LOAD SAVED SETTINGS ========== */
try {
  const saved = JSON.parse(localStorage.getItem(CM_KEY));
  if (saved && Array.isArray(saved.dH)) cmState = saved;
} catch {}

try {
  const savedWB = JSON.parse(localStorage.getItem(WB_KEY));
  if (savedWB) wb = savedWB;
} catch {}

try {
  const savedVig = +localStorage.getItem('vignetteAmtV1');
  if (!isNaN(savedVig)) vignetteAmt = savedVig;
} catch {}

try {
  const savedTricolor = JSON.parse(localStorage.getItem(TRICOLOR_KEY));
  if (savedTricolor) tricolorState = savedTricolor;
} catch {}

try {
  const savedHalation = JSON.parse(localStorage.getItem(HALATION_KEY));
  if (savedHalation) halationState = savedHalation;
} catch {}

/* ========== TABS ========== */
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab + '-panel').classList.add('active');
  });
});

/* ========== BOTTOM SHEET INTERACTION ========== */
let sheetExpanded = false;
let touchStartY = 0;
let sheetStartY = 0;

menuTrigger.addEventListener('click', (e) => {
  e.stopPropagation();
  sheetExpanded = !sheetExpanded;
  bottomSheet.classList.toggle('expanded', sheetExpanded);
});

// Close bottom sheet when clicking outside
document.addEventListener('click', (e) => {
  if (sheetExpanded && 
      !bottomSheet.contains(e.target) && 
      e.target !== menuTrigger) {
    sheetExpanded = false;
    bottomSheet.classList.remove('expanded');
  }
});

// Prevent clicks inside bottom sheet from closing it
bottomSheet.addEventListener('click', (e) => {
  e.stopPropagation();
});

sheetHandle.addEventListener('touchstart', (e) => {
  touchStartY = e.touches[0].clientY;
  sheetStartY = bottomSheet.getBoundingClientRect().top;
}, { passive: true });

sheetHandle.addEventListener('touchmove', (e) => {
  const deltaY = e.touches[0].clientY - touchStartY;
  if (deltaY > 0 && sheetExpanded) {
    bottomSheet.style.transform = `translateY(${deltaY}px)`;
  }
}, { passive: true });

sheetHandle.addEventListener('touchend', (e) => {
  const deltaY = e.changedTouches[0].clientY - touchStartY;
  bottomSheet.style.transform = '';
  if (deltaY > 100) {
    sheetExpanded = false;
    bottomSheet.classList.remove('expanded');
  }
});

/* ========== PRESETS ========== */
document.querySelectorAll('.preset-card').forEach(card => {
  card.addEventListener('click', () => {
    document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
    card.classList.add('active');
    film = card.dataset.preset;
    activeProfileName = null;
    if (lastFrameImageData) shootReprocess();
  });
});

/* ========== SLIDERS ========== */
const grainSlider = document.getElementById('grain');
const grainVal = document.getElementById('grain-val');
grainSlider.addEventListener('input', () => {
  grainAmt = +grainSlider.value;
  grainVal.textContent = grainAmt;
  if (lastFrameImageData) shootReprocess();
});

const jpegSlider = document.getElementById('jpeg-quality');
const jpegVal = document.getElementById('jpeg-quality-val');
jpegSlider.addEventListener('input', () => {
  jpegQ = +jpegSlider.value;
  jpegVal.textContent = jpegQ + '%';
});

const wbRSlider = document.getElementById('wb-r');
const wbRVal = document.getElementById('wb-r-val');
wbRSlider.addEventListener('input', () => {
  wb.r = +wbRSlider.value;
  wbRVal.textContent = wb.r;
  localStorage.setItem(WB_KEY, JSON.stringify(wb));
  if (lastFrameImageData) shootReprocess();
});

const wbBSlider = document.getElementById('wb-b');
const wbBVal = document.getElementById('wb-b-val');
wbBSlider.addEventListener('input', () => {
  wb.b = +wbBSlider.value;
  wbBVal.textContent = wb.b;
  localStorage.setItem(WB_KEY, JSON.stringify(wb));
  if (lastFrameImageData) shootReprocess();
});

const vignetteSlider = document.getElementById('vignette');
const vigVal = document.getElementById('vig-val');
vignetteSlider.addEventListener('input', () => {
  vignetteAmt = +vignetteSlider.value;
  vigVal.textContent = vignetteAmt;
  localStorage.setItem('vignetteAmtV1', String(vignetteAmt));
  if (lastFrameImageData) shootReprocess();
});

// Initialize slider displays
wbRVal.textContent = wb.r;
wbBVal.textContent = wb.b;
vigVal.textContent = vignetteAmt;
wbRSlider.value = wb.r;
wbBSlider.value = wb.b;
vignetteSlider.value = vignetteAmt;

/* ========== HALATION ========== */
const halationEnable = document.getElementById('halation-enable');
const halationWrapper = document.getElementById('halation-wrapper');
const halationBlur = document.getElementById('halation-blur');
const halationStrength = document.getElementById('halation-strength');
const halationThreshold = document.getElementById('halation-threshold');
const halationBlurVal = document.getElementById('halation-blur-val');
const halationStrengthVal = document.getElementById('halation-strength-val');
const halationThresholdVal = document.getElementById('halation-threshold-val');

function updateHalationUI() {
  halationEnable.checked = halationState.enable;
  halationWrapper.style.display = halationState.enable ? 'block' : 'none';
  halationBlur.value = halationState.blur;
  halationStrength.value = halationState.strength;
  halationThreshold.value = halationState.threshold;
  halationBlurVal.textContent = halationState.blur;
  halationStrengthVal.textContent = halationState.strength;
  halationThresholdVal.textContent = halationState.threshold;
}

function saveHalationState() {
  localStorage.setItem(HALATION_KEY, JSON.stringify(halationState));
}

halationEnable.addEventListener('change', () => {
  halationState.enable = halationEnable.checked;
  halationWrapper.style.display = halationState.enable ? 'block' : 'none';
  saveHalationState();
  if (lastFrameImageData) shootReprocess();
});

halationBlur.addEventListener('input', () => {
  halationState.blur = +halationBlur.value;
  halationBlurVal.textContent = halationState.blur;
  saveHalationState();
  if (lastFrameImageData) shootReprocess();
});

halationStrength.addEventListener('input', () => {
  halationState.strength = +halationStrength.value;
  halationStrengthVal.textContent = halationState.strength;
  saveHalationState();
  if (lastFrameImageData) shootReprocess();
});

halationThreshold.addEventListener('input', () => {
  halationState.threshold = +halationThreshold.value;
  halationThresholdVal.textContent = halationState.threshold;
  saveHalationState();
  if (lastFrameImageData) shootReprocess();
});

updateHalationUI();

/* ========== COLOR MIX ========== */
const cmEnable = document.getElementById('cm-enable');
const cmWrapper = document.getElementById('cm-wrapper');
const colorPalette = document.getElementById('color-palette');
const colorInfo = document.getElementById('color-info');
const cmH = document.getElementById('cm-h');
const cmS = document.getElementById('cm-s');
const cmL = document.getElementById('cm-l');
const cmHVal = document.getElementById('cm-h-val');
const cmSVal = document.getElementById('cm-s-val');
const cmLVal = document.getElementById('cm-l-val');
const cmReset = document.getElementById('cm-reset');

function buildColorPalette() {
  colorPalette.innerHTML = '';
  colors.forEach((c, i) => {
    const chip = document.createElement('div');
    chip.className = 'color-chip' + (i === cmIdx ? ' selected' : '');
    chip.style.background = c.css;
    chip.addEventListener('click', () => {
      cmIdx = i;
      buildColorPalette();
      updateColorControls();
    });
    colorPalette.appendChild(chip);
  });
}

function updateColorControls() {
  colorInfo.textContent = `${colors[cmIdx].name} ‚Ä¢ Hue ${Math.round(cmState.dH[cmIdx]*360)}¬∞ ‚Ä¢ Sat ${Math.round(cmState.dS[cmIdx]*200)} ‚Ä¢ Lum ${Math.round(cmState.dL[cmIdx]*200)}`;
  cmH.value = Math.round(cmState.dH[cmIdx] * 360);
  cmS.value = Math.round(cmState.dS[cmIdx] * 200);
  cmL.value = Math.round(cmState.dL[cmIdx] * 200);
  cmHVal.textContent = cmH.value + '¬∞';
  cmSVal.textContent = cmS.value;
  cmLVal.textContent = cmL.value;
}

cmH.addEventListener('input', () => {
  cmState.dH[cmIdx] = (+cmH.value) / 360;
  cmHVal.textContent = cmH.value + '¬∞';
  updateColorControls();
  localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  if (lastFrameImageData) shootReprocess();
});

cmS.addEventListener('input', () => {
  cmState.dS[cmIdx] = (+cmS.value) / 200;
  cmSVal.textContent = cmS.value;
  updateColorControls();
  localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  if (lastFrameImageData) shootReprocess();
});

cmL.addEventListener('input', () => {
  cmState.dL[cmIdx] = (+cmL.value) / 200;
  cmLVal.textContent = cmL.value;
  updateColorControls();
  localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  if (lastFrameImageData) shootReprocess();
});

cmReset.addEventListener('click', () => {
  cmState.dH.fill(0);
  cmState.dS.fill(0);
  cmState.dL.fill(0);
  updateColorControls();
  buildColorPalette();
  localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  if (lastFrameImageData) shootReprocess();
});

cmEnable.checked = cmState.enable;
cmWrapper.style.display = cmState.enable ? 'block' : 'none';
buildColorPalette();
updateColorControls();

/* ========== TRICOLOR WHEEL ========== */
const tricolorEnable = document.getElementById('tricolor-enable');
const tricolorWrapper = document.getElementById('tricolor-wrapper');

// Sliders
const shadowHue = document.getElementById('shadow-hue');
const shadowStr = document.getElementById('shadow-strength');
const shadowHueVal = document.getElementById('shadow-hue-val');
const shadowStrVal = document.getElementById('shadow-str-val');

const midtoneHue = document.getElementById('midtone-hue');
const midtoneStr = document.getElementById('midtone-strength');
const midtoneHueVal = document.getElementById('midtone-hue-val');
const midtoneStrVal = document.getElementById('midtone-str-val');

const highlightHue = document.getElementById('highlight-hue');
const highlightStr = document.getElementById('highlight-strength');
const highlightHueVal = document.getElementById('highlight-hue-val');
const highlightStrVal = document.getElementById('highlight-str-val');

const tricolorReset = document.getElementById('tricolor-reset');

// Color wheels
const shadowWheel = document.getElementById('shadow-wheel');
const midtoneWheel = document.getElementById('midtone-wheel');
const highlightWheel = document.getElementById('highlight-wheel');

function updateTricolorUI() {
  tricolorEnable.checked = tricolorState.enable;
  tricolorWrapper.style.display = tricolorState.enable ? 'block' : 'none';
  
  // Update shadow
  shadowHue.value = tricolorState.shadow.hue;
  shadowStr.value = tricolorState.shadow.strength;
  shadowHueVal.textContent = tricolorState.shadow.hue + '¬∞';
  shadowStrVal.textContent = tricolorState.shadow.strength + '%';
  updateWheelIndicator(shadowWheel, tricolorState.shadow.hue);
  
  // Update midtone
  midtoneHue.value = tricolorState.midtone.hue;
  midtoneStr.value = tricolorState.midtone.strength;
  midtoneHueVal.textContent = tricolorState.midtone.hue + '¬∞';
  midtoneStrVal.textContent = tricolorState.midtone.strength + '%';
  updateWheelIndicator(midtoneWheel, tricolorState.midtone.hue);
  
  // Update highlight
  highlightHue.value = tricolorState.highlight.hue;
  highlightStr.value = tricolorState.highlight.strength;
  highlightHueVal.textContent = tricolorState.highlight.hue + '¬∞';
  highlightStrVal.textContent = tricolorState.highlight.strength + '%';
  updateWheelIndicator(highlightWheel, tricolorState.highlight.hue);
}

function updateWheelIndicator(wheel, hue) {
  const percent = (hue / 360) * 100;
  wheel.style.setProperty('--indicator-left', percent + '%');
}

function saveTricolorState() {
  localStorage.setItem(TRICOLOR_KEY, JSON.stringify(tricolorState));
}

// Mutual exclusivity
tricolorEnable.addEventListener('change', () => {
  tricolorState.enable = tricolorEnable.checked;
  if (tricolorState.enable) {
    cmState.enable = false;
    cmEnable.checked = false;
    cmWrapper.style.display = 'none';
  }
  tricolorWrapper.style.display = tricolorState.enable ? 'block' : 'none';
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

cmEnable.addEventListener('change', () => {
  cmState.enable = cmEnable.checked;
  if (cmState.enable) {
    tricolorState.enable = false;
    tricolorEnable.checked = false;
    tricolorWrapper.style.display = 'none';
  }
  cmWrapper.style.display = cmState.enable ? 'block' : 'none';
  localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

// Shadow controls
shadowHue.addEventListener('input', () => {
  tricolorState.shadow.hue = +shadowHue.value;
  shadowHueVal.textContent = tricolorState.shadow.hue + '¬∞';
  updateWheelIndicator(shadowWheel, tricolorState.shadow.hue);
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

shadowStr.addEventListener('input', () => {
  tricolorState.shadow.strength = +shadowStr.value;
  shadowStrVal.textContent = tricolorState.shadow.strength + '%';
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

// Midtone controls
midtoneHue.addEventListener('input', () => {
  tricolorState.midtone.hue = +midtoneHue.value;
  midtoneHueVal.textContent = tricolorState.midtone.hue + '¬∞';
  updateWheelIndicator(midtoneWheel, tricolorState.midtone.hue);
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

midtoneStr.addEventListener('input', () => {
  tricolorState.midtone.strength = +midtoneStr.value;
  midtoneStrVal.textContent = tricolorState.midtone.strength + '%';
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

// Highlight controls
highlightHue.addEventListener('input', () => {
  tricolorState.highlight.hue = +highlightHue.value;
  highlightHueVal.textContent = tricolorState.highlight.hue + '¬∞';
  updateWheelIndicator(highlightWheel, tricolorState.highlight.hue);
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

highlightStr.addEventListener('input', () => {
  tricolorState.highlight.strength = +highlightStr.value;
  highlightStrVal.textContent = tricolorState.highlight.strength + '%';
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

// Wheel click handlers
function handleWheelClick(wheel, type) {
  wheel.addEventListener('click', (e) => {
    const rect = wheel.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percent = x / rect.width;
    const hue = Math.round(percent * 360);
    
    tricolorState[type].hue = hue;
    
    if (type === 'shadow') {
      shadowHue.value = hue;
      shadowHueVal.textContent = hue + '¬∞';
    } else if (type === 'midtone') {
      midtoneHue.value = hue;
      midtoneHueVal.textContent = hue + '¬∞';
    } else {
      highlightHue.value = hue;
      highlightHueVal.textContent = hue + '¬∞';
    }
    
    updateWheelIndicator(wheel, hue);
    saveTricolorState();
    if (lastFrameImageData) shootReprocess();
  });
}

handleWheelClick(shadowWheel, 'shadow');
handleWheelClick(midtoneWheel, 'midtone');
handleWheelClick(highlightWheel, 'highlight');

tricolorReset.addEventListener('click', () => {
  tricolorState.shadow = { hue: 180, strength: 0 };
  tricolorState.midtone = { hue: 180, strength: 0 };
  tricolorState.highlight = { hue: 180, strength: 0 };
  updateTricolorUI();
  saveTricolorState();
  if (lastFrameImageData) shootReprocess();
});

updateTricolorUI();

/* ========== PROFILES ========== */
function loadProfiles() {
  try {
    const raw = JSON.parse(localStorage.getItem(PROFILE_KEY));
    if (raw) profiles = raw;
  } catch {}
  renderProfiles();
}

function renderProfiles() {
  const container = document.getElementById('custom-profiles');
  container.innerHTML = '';
  
  Object.keys(profiles).forEach(name => {
    const profile = profiles[name];
    const isImported = profile._imported === true;
    
    const card = document.createElement('div');
    card.className = 'preset-card';
    
    // Only add share button if NOT imported
    const shareButtonHTML = isImported 
      ? '' 
      : '<button class="preset-share-btn" title="Share preset">üì§</button>';
    
    const descText = isImported ? 'Received preset' : 'Custom profile';
    
    card.innerHTML = `
      <button class="preset-delete-btn" title="Delete preset">üóëÔ∏è</button>
      ${shareButtonHTML}
      <div class="preset-name">${name}</div>
      <div class="preset-desc">${descText}</div>
    `;
    
    // Click on card to load preset
    card.addEventListener('click', (e) => {
      // Don't trigger if clicking action buttons
      if (e.target.classList.contains('preset-share-btn') || 
          e.target.classList.contains('preset-delete-btn')) return;
      
      document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      activeProfileName = name;
      applyProfile(name);
    });
    
    // Delete button functionality
    const deleteBtn = card.querySelector('.preset-delete-btn');
    deleteBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      deletePreset(name);
    });
    
    // Share button functionality (only if not imported)
    if (!isImported) {
      const shareBtn = card.querySelector('.preset-share-btn');
      if (shareBtn) {
        shareBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await sharePreset(name);
        });
      }
    }
    
    container.appendChild(card);
  });
}

function applyProfile(name) {
  const p = profiles[name];
  if (!p) return;
  
  film = p.filmBase || 'kodachrome';
  grainAmt = p.grainAmt || 19;
  grainSlider.value = grainAmt;
  grainVal.textContent = grainAmt;
  
  if (p.cmState) {
    cmState = JSON.parse(JSON.stringify(p.cmState));
    cmEnable.checked = cmState.enable;
    cmWrapper.style.display = cmState.enable ? 'block' : 'none';
    updateColorControls();
    buildColorPalette();
    localStorage.setItem(CM_KEY, JSON.stringify(cmState));
  }
  
  if (p.wb) {
    wb = { r: p.wb.r || 0, b: p.wb.b || 0 };
    wbRSlider.value = wb.r;
    wbBSlider.value = wb.b;
    wbRVal.textContent = wb.r;
    wbBVal.textContent = wb.b;
    localStorage.setItem(WB_KEY, JSON.stringify(wb));
  }
  
  if (typeof p.vignetteAmt === 'number') {
    vignetteAmt = p.vignetteAmt;
    vignetteSlider.value = vignetteAmt;
    vigVal.textContent = vignetteAmt;
    localStorage.setItem('vignetteAmtV1', String(vignetteAmt));
  }
  
  if (p.tricolorState) {
    tricolorState = JSON.parse(JSON.stringify(p.tricolorState));
    updateTricolorUI();
    saveTricolorState();
  }
  
  if (p.halationState) {
    halationState = JSON.parse(JSON.stringify(p.halationState));
    updateHalationUI();
    saveHalationState();
  }
  
  if (lastFrameImageData) shootReprocess();
}

/* ========== PRESET SHARING ========== */
function deletePreset(presetName) {
  if (!confirm(`Delete preset "${presetName}"?\n\nThis cannot be undone.`)) {
    return;
  }
  
  // Remove from profiles object
  delete profiles[presetName];
  
  // Save to localStorage
  localStorage.setItem(PROFILE_KEY, JSON.stringify(profiles));
  
  // If this was the active profile, clear it
  if (activeProfileName === presetName) {
    activeProfileName = null;
  }
  
  // Refresh UI
  renderProfiles();
}

async function sharePreset(presetName) {
  const preset = profiles[presetName];
  if (!preset) return;
  
  // Create shareable package
  const sharePackage = {
    v: 1, // version
    n: presetName, // name
    d: preset, // data
    t: Date.now() // timestamp
  };
  
  // Encode to base64
  const jsonStr = JSON.stringify(sharePackage);
  const encoded = btoa(encodeURIComponent(jsonStr));
  
  // Copy to clipboard
  try {
    await navigator.clipboard.writeText(encoded);
    alert(`‚úÖ Preset "${presetName}" copied to clipboard!\n\nShare this code with your friend.`);
    
    // Auto-clear clipboard after 60 seconds
    setTimeout(async () => {
      try {
        const current = await navigator.clipboard.readText();
        if (current === encoded) {
          await navigator.clipboard.writeText('null');
        }
      } catch {}
    }, 60000);
  } catch (err) {
    // Fallback: show in prompt
    prompt('Copy this preset code:', encoded);
  }
}

async function importPreset() {
  let code = prompt('Paste the preset code you received:');
  if (!code || code.trim() === '' || code.trim() === 'null') return;
  
  code = code.trim();
  
  try {
    // Decode from base64
    const jsonStr = decodeURIComponent(atob(code));
    const sharePackage = JSON.parse(jsonStr);
    
    // Validate structure
    if (!sharePackage.v || !sharePackage.n || !sharePackage.d) {
      throw new Error('Invalid preset format');
    }
    
    // Check if preset already exists
    let finalName = sharePackage.n;
    let counter = 1;
    while (profiles[finalName]) {
      finalName = `${sharePackage.n} (${counter})`;
      counter++;
    }
    
    // Mark as imported (non-shareable)
    const importedPreset = sharePackage.d;
    importedPreset._imported = true;
    importedPreset._importedAt = Date.now();
    
    // Save as permanent preset
    profiles[finalName] = importedPreset;
    localStorage.setItem(PROFILE_KEY, JSON.stringify(profiles));
    
    // Refresh UI
    renderProfiles();
    
    // Clear clipboard
    try {
      await navigator.clipboard.writeText('null');
    } catch {}
    
    alert(`‚úÖ Preset "${finalName}" imported successfully!`);
    
  } catch (err) {
    alert('‚ùå Invalid preset code. Please check and try again.');
  }
}

document.getElementById('save-profile-btn').addEventListener('click', () => {
  const name = prompt('Profile name?');
  if (!name) return;
  
  profiles[name] = {
    filmBase: film,
    grainAmt,
    cmState: JSON.parse(JSON.stringify(cmState)),
    wb: { ...wb },
    vignetteAmt,
    tricolorState: JSON.parse(JSON.stringify(tricolorState)),
    halationState: JSON.parse(JSON.stringify(halationState))
  };
  
  localStorage.setItem(PROFILE_KEY, JSON.stringify(profiles));
  renderProfiles();
  alert('Profile saved: ' + name);
});

document.getElementById('import-preset-btn').addEventListener('click', () => {
  importPreset();
});

/* ========== CAMERA ========== */
async function bootCam(id = null) {
  if (stream) stream.getTracks().forEach(t => t.stop());
  const c = { 
    video: id 
      ? { deviceId: {exact: id}, width: {ideal: 1920}, height: {ideal: 1080} }
      : { facingMode: {ideal: 'environment'}, width: {ideal: 1920}, height: {ideal: 1080} }
  };
  
  try {
    stream = await navigator.mediaDevices.getUserMedia(c);
    video.srcObject = stream;
    await video.play();
    await updateCameraList();
  } catch (e) {
    alert('Camera error: ' + e.message);
  }
}

async function updateCameraList() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cameras = devices.filter(d => d.kind === 'videoinput');
  
  cameraSelect.innerHTML = '';
  cameras.forEach((d, i) => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.textContent = d.label || `Camera ${i+1}`;
    cameraSelect.appendChild(opt);
  });
}

document.getElementById('camera-switch').addEventListener('click', () => {
  const selector = document.getElementById('camera-selector');
  if (selector.style.display === 'flex') {
    selector.style.display = 'none';
    return;
  }
  
  selector.innerHTML = '';
  Array.from(cameraSelect.options).forEach(opt => {
    const btn = document.createElement('div');
    btn.className = 'camera-option';
    btn.textContent = opt.textContent;
    btn.addEventListener('click', () => {
      bootCam(opt.value);
      selector.style.display = 'none';
    });
    selector.appendChild(btn);
  });
  selector.style.display = 'flex';
});

/* ========== WORKER ========== */
const workerSrc = `
self.onmessage = (e) => {
  const { imageData, film, grainAmt, cmState, colors, hueWidth, wb, vignetteAmt, tricolorState, halationState } = e.data;
  const d = imageData.data;
  const useColorMix = cmState.enable && film !== 'acros';
  const useTricolor = tricolorState.enable && film !== 'acros';
  const useHalation = halationState.enable;

  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const M = Math.max(r,g,b), m = Math.min(r,g,b), delt = M - m;
    let h = 0;
    if (delt > 1e-6){
      if (M === r) h = ((g - b) / delt) % 6;
      else if (M === g) h = (b - r) / delt + 2;
      else h = (r - g) / delt + 4;
      h /= 6; if (h<0) h+=1;
    }
    const s = M <= 1e-6 ? 0 : delt / M;
    return [h, s, M];
  }
  
  function hsvToRgb(h,s,v){
    h = (h%1+1)%1;
    const x = h*6, i = Math.floor(x), f = x - i;
    const p = v*(1-s), q = v*(1-s*f), t = v*(1-s*(1-f));
    let r,g,b;
    if (i===0){ r=v; g=t; b=p; }
    else if (i===1){ r=q; g=v; b=p; }
    else if (i===2){ r=p; g=v; b=t; }
    else if (i===3){ r=p; g=q; b=v; }
    else if (i===4){ r=t; g=p; b=v; }
    else { r=v; g=p; b=q; }
    return [Math.max(0,Math.min(255,Math.round(r*255))),
            Math.max(0,Math.min(255,Math.round(g*255))),
            Math.max(0,Math.min(255,Math.round(b*255)))];
  }
  
  function hueDelta(a,b){ const d = Math.abs(a-b); return Math.min(d, 1 - d); }
  function bucketWeight(h, s, center, halfWidth){
    const dh = hueDelta(h, center);
    if (dh >= halfWidth) return 0;
    const wHue = 0.5 * (1 + Math.cos(Math.PI * (dh/halfWidth)));
    const minChroma = 0.02, maxChroma = 0.95;
    const gate = Math.min(1, Math.max(0, (s - minChroma) / (maxChroma - minChroma)));
    return wHue * gate;
  }

  let seed = 1234567;
  function fastNoise(){
    seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5;
    return ((seed>>>0) / 0x7fffffff) * 2 - 1;
  }

  const gainR = 1 + (wb.r || 0) * 0.06;
  const gainB = 1 + (wb.b || 0) * 0.06;

  const W = imageData.width, H = imageData.height;
  const cx = W * 0.5, cy = H * 0.5;
  const maxR = Math.min(W, H) * 0.5;
  const vigPower = (vignetteAmt||0) / 100;

  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      const i = (y*W + x) * 4;
      let r = d[i], g = d[i+1], bl = d[i+2];

      if (film === 'acros'){
        const a = (r+g+bl)/3;
        r=g=bl=a;
      } else {
        const a = (r+g+bl)/3;
        r = r*.85 + a*.15;
        g = g*.85 + a*.15;
        bl = bl*.85 + a*.15;
      }

      if (useColorMix){
        let [h, s, v] = rgbToHsv(r,g,bl);
        let dH=0, dS=0, dL=0, sumW=0;
        for (let k=0; k<8; k++){
          const w = bucketWeight(h, s, colors[k].center, hueWidth[k]);
          if (w>0){
            sumW += w;
            dH += w * (cmState.dH[k] || 0);
            dS += w * (cmState.dS[k] || 0);
            dL += w * (cmState.dL[k] || 0);
          }
        }
        if (sumW>0){
          h = h + dH;
          s = Math.max(0, Math.min(1, s + dS));
          v = Math.max(0, Math.min(1, v + dL));
          [r,g,bl] = hsvToRgb(h,s,v);
        }
      }

      // Tricolor grading (shadows/midtones/highlights)
      if (useTricolor){
        const lum = (r + g + bl) / 3;
        const lumNorm = lum / 255; // 0 to 1
        
        // Determine luminance zone weights
        let shadowWeight = 0, midtoneWeight = 0, highlightWeight = 0;
        
        if (lumNorm < 0.33) {
          // Shadows zone
          shadowWeight = 1 - (lumNorm / 0.33);
          midtoneWeight = lumNorm / 0.33;
        } else if (lumNorm < 0.67) {
          // Midtones zone
          const midPos = (lumNorm - 0.33) / 0.34;
          midtoneWeight = 1 - Math.abs(midPos - 0.5) * 2;
          if (lumNorm < 0.5) {
            shadowWeight = 1 - midPos * 2;
          } else {
            highlightWeight = (midPos - 0.5) * 2;
          }
        } else {
          // Highlights zone
          highlightWeight = (lumNorm - 0.67) / 0.33;
          midtoneWeight = 1 - highlightWeight;
        }
        
        // Apply color tints based on strength
        if (shadowWeight > 0 && tricolorState.shadow.strength > 0) {
          const strength = (tricolorState.shadow.strength / 100) * shadowWeight;
          const hue = tricolorState.shadow.hue;
          const [tr, tg, tb] = hsvToRgb(hue / 360, 1, 1);
          r = r * (1 - strength * 0.5) + tr * strength * 0.5;
          g = g * (1 - strength * 0.5) + tg * strength * 0.5;
          bl = bl * (1 - strength * 0.5) + tb * strength * 0.5;
        }
        
        if (midtoneWeight > 0 && tricolorState.midtone.strength > 0) {
          const strength = (tricolorState.midtone.strength / 100) * midtoneWeight;
          const hue = tricolorState.midtone.hue;
          const [tr, tg, tb] = hsvToRgb(hue / 360, 1, 1);
          r = r * (1 - strength * 0.5) + tr * strength * 0.5;
          g = g * (1 - strength * 0.5) + tg * strength * 0.5;
          bl = bl * (1 - strength * 0.5) + tb * strength * 0.5;
        }
        
        if (highlightWeight > 0 && tricolorState.highlight.strength > 0) {
          const strength = (tricolorState.highlight.strength / 100) * highlightWeight;
          const hue = tricolorState.highlight.hue;
          const [tr, tg, tb] = hsvToRgb(hue / 360, 1, 1);
          r = r * (1 - strength * 0.5) + tr * strength * 0.5;
          g = g * (1 - strength * 0.5) + tg * strength * 0.5;
          bl = bl * (1 - strength * 0.5) + tb * strength * 0.5;
        }
      }

      r = r * gainR;
      bl = bl * gainB;

      if (grainAmt > 0){
        // Exponential scaling for more subtle low-end control
        // grainAmt 0-50 maps to actualIntensity 0-20 with exponential curve
        const normalizedGrain = grainAmt / 50; // 0 to 1
        const actualIntensity = Math.pow(normalizedGrain, 1.8) * 20;
        
        // Generate grain for each channel with slight variation
        const baseNoise = fastNoise();
        const rNoise = (baseNoise + fastNoise() * 0.3) * actualIntensity;
        const gNoise = (baseNoise + fastNoise() * 0.3) * actualIntensity;
        const bNoise = (baseNoise + fastNoise() * 0.3) * actualIntensity;
        
        // Apply grain with luminance-dependent intensity (more visible in midtones)
        const lum = (r + g + bl) / 3;
        const lumFactor = 1 - Math.abs((lum / 255) - 0.5) * 0.6; // Peaks at midtones
        
        r += rNoise * lumFactor;
        g += gNoise * lumFactor;
        bl += bNoise * lumFactor;
      }

      if (vigPower > 0){
        const dx = x - cx, dy = y - cy;
        const rr = Math.sqrt(dx*dx + dy*dy) / maxR;
        const fall = Math.min(1, Math.max(0, rr));
        const vFactor = 1 - vigPower * (fall*fall);
        r *= vFactor; g *= vFactor; bl *= vFactor;
      }

      d[i] = r < 0 ? 0 : r > 255 ? 255 : r;
      d[i+1] = g < 0 ? 0 : g > 255 ? 255 : g;
      d[i+2] = bl < 0 ? 0 : bl > 255 ? 255 : bl;
    }
  }

  // Apply halation effect (after all other processing)
  if (useHalation) {
    const { blur, strength, threshold } = halationState;
    
    // Step 1: Create a copy for thresholding
    const brightPixels = new Uint8ClampedArray(d.length);
    for (let i = 0; i < d.length; i += 4) {
      const brightness = (d[i] + d[i+1] + d[i+2]) / 3;
      if (brightness >= threshold) {
        brightPixels[i] = 255;
        brightPixels[i+1] = 255;
        brightPixels[i+2] = 255;
        brightPixels[i+3] = 255;
      }
    }
    
    // Step 2: Apply gaussian blur approximation (box blur)
    const blurRadius = Math.max(1, Math.round(blur));
    const blurred = new Uint8ClampedArray(brightPixels.length);
    
    // Horizontal blur pass
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        let sumR = 0, sumG = 0, sumB = 0, count = 0;
        for (let dx = -blurRadius; dx <= blurRadius; dx++) {
          const nx = x + dx;
          if (nx >= 0 && nx < W) {
            const idx = (y * W + nx) * 4;
            sumR += brightPixels[idx];
            sumG += brightPixels[idx + 1];
            sumB += brightPixels[idx + 2];
            count++;
          }
        }
        const idx = (y * W + x) * 4;
        blurred[idx] = sumR / count;
        blurred[idx + 1] = sumG / count;
        blurred[idx + 2] = sumB / count;
      }
    }
    
    // Vertical blur pass
    const blurred2 = new Uint8ClampedArray(blurred.length);
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        let sumR = 0, sumG = 0, sumB = 0, count = 0;
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          const ny = y + dy;
          if (ny >= 0 && ny < H) {
            const idx = (ny * W + x) * 4;
            sumR += blurred[idx];
            sumG += blurred[idx + 1];
            sumB += blurred[idx + 2];
            count++;
          }
        }
        const idx = (y * W + x) * 4;
        blurred2[idx] = sumR / count;
        blurred2[idx + 1] = sumG / count;
        blurred2[idx + 2] = sumB / count;
      }
    }
    
    // Step 3: Convert to red channel only and apply strength
    for (let i = 0; i < blurred2.length; i += 4) {
      if (blurred2[i] > 0 || blurred2[i+1] > 0 || blurred2[i+2] > 0) {
        const brightness = (blurred2[i] + blurred2[i+1] + blurred2[i+2]) / 3;
        blurred2[i] = Math.min(255, brightness + strength);
        blurred2[i+1] = 0;
        blurred2[i+2] = 0;
      }
    }
    
    // Step 4: Apply second blur to red glow
    const finalBlurred = new Uint8ClampedArray(blurred2.length);
    
    // Horizontal blur pass
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        let sumR = 0, count = 0;
        for (let dx = -blurRadius; dx <= blurRadius; dx++) {
          const nx = x + dx;
          if (nx >= 0 && nx < W) {
            const idx = (y * W + nx) * 4;
            sumR += blurred2[idx];
            count++;
          }
        }
        const idx = (y * W + x) * 4;
        finalBlurred[idx] = sumR / count;
      }
    }
    
    // Vertical blur pass
    const finalBlurred2 = new Uint8ClampedArray(finalBlurred.length);
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        let sumR = 0, count = 0;
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          const ny = y + dy;
          if (ny >= 0 && ny < H) {
            const idx = (ny * W + x) * 4;
            sumR += finalBlurred[idx];
            count++;
          }
        }
        const idx = (y * W + x) * 4;
        finalBlurred2[idx] = sumR / count;
      }
    }
    
    // Step 5: Blend with original using screen mode
    for (let i = 0; i < d.length; i += 4) {
      const halationR = finalBlurred2[i];
      if (halationR > 0) {
        // Screen blend: 1 - (1-a) * (1-b)
        const origR = d[i] / 255;
        const origG = d[i+1] / 255;
        const origB = d[i+2] / 255;
        const halR = halationR / 255;
        
        d[i] = Math.min(255, (1 - (1 - origR) * (1 - halR)) * 255);
        d[i+1] = Math.min(255, (1 - (1 - origG) * (1 - halR)) * 255);
        d[i+2] = Math.min(255, (1 - (1 - origB) * (1 - halR)) * 255);
      }
    }
  }

  self.postMessage({ imageData }, [imageData.data.buffer]);
};
`;
const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], {type: 'application/javascript'})));

/* ========== SHOOT ========== */
shutter.addEventListener('click', () => {
  userText = '';
  shoot();
});

async function shoot() {
  if (!video.videoWidth) {
    alert('Wait for camera');
    return;
  }

  const w = video.videoWidth;
  const h = video.videoHeight;
  const b = Math.floor(Math.min(w, h) * 0.09);
  const fw = w + b * 2;
  const bot = b * 2;
  const fh = h + b + bot;

  canvas.width = fw;
  canvas.height = fh;
  dim = { fw, fh, b, bot };

  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, fw, fh);
  ctx.drawImage(video, b, b, w, h);

  canvas.style.display = 'block';
  video.style.display = 'none';
  nextBtn.style.display = 'flex';
  textBtn.style.display = 'flex';
  saveBtn.style.display = 'flex';
  
  // Close bottom sheet when taking photo
  sheetExpanded = false;
  bottomSheet.classList.remove('expanded');

  const roi = ctx.getImageData(b, b, w, h);
  processingEl.style.display = 'flex';

  worker.postMessage({
    imageData: roi,
    film: activeProfileName && profiles[activeProfileName] ? profiles[activeProfileName].filmBase : film,
    grainAmt,
    cmState,
    colors,
    hueWidth,
    wb,
    vignetteAmt,
    tricolorState,
    halationState
  }, [roi.data.buffer]);

  worker.onmessage = (e) => {
    const { imageData } = e.data;
    ctx.putImageData(imageData, b, b);
    lastFrameImageData = ctx.getImageData(0, 0, fw, fh);
    drawText(ctx);
    processingEl.style.display = 'none';
  };
}

function shootReprocess() {
  if (!dim) return;
  const { fw, fh, b, bot } = dim;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const roi = ctx.getImageData(b, b, canvas.width - b * 2, canvas.height - b * 2 - (bot - b));
  
  processingEl.style.display = 'flex';

  worker.postMessage({
    imageData: roi,
    film: activeProfileName && profiles[activeProfileName] ? profiles[activeProfileName].filmBase : film,
    grainAmt,
    cmState,
    colors,
    hueWidth,
    wb,
    vignetteAmt,
    tricolorState,
    halationState
  }, [roi.data.buffer]);

  worker.onmessage = (e) => {
    const { imageData } = e.data;
    ctx.putImageData(imageData, b, b);
    lastFrameImageData = ctx.getImageData(0, 0, fw, fh);
    drawText(ctx);
    processingEl.style.display = 'none';
  };
}

/* ========== TEXT ========== */
const textModal = document.getElementById('text-modal');
const textInput = document.getElementById('text-input');

textBtn.addEventListener('click', () => {
  textModal.style.display = 'flex';
  textInput.focus();
});

document.getElementById('text-cancel').addEventListener('click', () => {
  textModal.style.display = 'none';
  textInput.value = '';
});

document.getElementById('text-submit').addEventListener('click', async () => {
  userText = textInput.value.trim();
  if (userText) {
    // Ensure font is loaded before drawing
    if (document.fonts) {
      await document.fonts.load('131px "Mrs Saint Delafield"').catch(() => {});
    }
    updateText();
  }
  textModal.style.display = 'none';
  textInput.value = '';
});

function updateText() {
  if (!dim) return;
  const ctx = canvas.getContext('2d');
  // Restore the processed image WITHOUT text
  if (lastFrameImageData) ctx.putImageData(lastFrameImageData, 0, 0);
  // Draw text fresh on top
  drawText(ctx);
}

function drawText(ctx) {
  if (!userText || !dim) return;
  const { fw, fh, bot } = dim;
  
  // Ensure font is loaded before drawing
  if (document.fonts) {
    document.fonts.load('131px "Mrs Saint Delafield"').catch(() => {});
  }
  
  let fs = 131;
  ctx.font = `${fs}px "Mrs Saint Delafield", cursive`;
  while (ctx.measureText(userText).width > fw - 20 && fs > 16) {
    fs--;
    ctx.font = `${fs}px "Mrs Saint Delafield", cursive`;
  }
  
  ctx.fillStyle = '#000';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(userText, fw / 2, fh - bot / 2);
  // DO NOT update lastFrameImageData here - it should stay as the image without text
}

/* ========== NEXT/RESET ========== */
nextBtn.addEventListener('click', () => {
  video.style.display = 'block';
  canvas.style.display = 'none';
  nextBtn.style.display = 'none';
  textBtn.style.display = 'none';
  saveBtn.style.display = 'none';
  lastFrameImageData = null;
  dim = null;
  userText = '';
});

/* ========== SAVE ========== */
saveBtn.addEventListener('click', () => {
  if (!dim) {
    alert('Take a photo first');
    return;
  }
  
  const { fw, fh } = dim;
  const scale = 1810 / 4420;
  const tmp = document.createElement('canvas');
  
  tmp.width = Math.floor(fw * scale);
  tmp.height = Math.floor(fh * scale);
  const tctx = tmp.getContext('2d');
  tctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);
  
  tmp.toBlob(blob => {
    if (!blob) {
      alert('Save failed');
      return;
    }
    
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `photo-${Date.now()}.jpg`;
    a.click();
    URL.revokeObjectURL(a.href);
    
    const fr = new FileReader();
    fr.onloadend = () => localStorage.setItem(`saved-photo-${Date.now()}`, fr.result);
    fr.readAsDataURL(blob);
  }, 'image/jpeg', jpegQ / 100);
});

/* ========== GALLERY ========== */
document.getElementById('gallery-btn').addEventListener('click', () => {
  const content = document.getElementById('gallery-content');
  content.innerHTML = '';
  
  const keys = Object.keys(localStorage)
    .filter(k => k.startsWith('saved-photo-'))
    .sort()
    .reverse();
  
  if (!keys.length) {
    content.innerHTML = '<p style="color: rgba(255,255,255,0.6); text-align: center; padding: 40px;">No saved images</p>';
  } else {
    keys.forEach(k => {
      const img = document.createElement('img');
      img.src = localStorage.getItem(k);
      content.appendChild(img);
    });
  }
  
  document.getElementById('gallery-overlay').style.display = 'flex';
});

document.getElementById('gallery-close').addEventListener('click', () => {
  document.getElementById('gallery-overlay').style.display = 'none';
});

/* ========== INIT ========== */
loadProfiles();
bootCam();

// Prevent context menu except on photo
document.addEventListener('contextmenu', e => {
  if (e.target.id !== 'photo') e.preventDefault();
}, { passive: false });
</script>

</body>
</html>
